using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace R3Ext.Bindings.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class BindingGeneratorV2 : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var invocations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is InvocationExpressionSyntax ies && LooksLikeBindingInvocation(ies),
                static (ctx, _) => Transform(ctx))
            .Where(m => m is not null)!;

        var collected = invocations.Collect();

        context.RegisterSourceOutput(collected, static (spc, models) =>
        {
            var all = models!.OfType<InvocationModel>().ToImmutableArray();
            if (all.IsDefaultOrEmpty) return;

            var emitter = new CodeEmitter();
            var source = emitter.Emit(all);
            spc.AddSource("R3Ext_BindingGeneratorV2.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool LooksLikeBindingInvocation(InvocationExpressionSyntax ies)
    {
        if (ies.Expression is MemberAccessExpressionSyntax maes)
        {
            var name = maes.Name.Identifier.ValueText;
            return name is "BindTwoWay" or "BindOneWay" or "WhenChanged";
        }
        return false;
    }

    private static InvocationModel? Transform(GeneratorSyntaxContext ctx)
    {
        var ies = (InvocationExpressionSyntax)ctx.Node;
        if (ies.Expression is not MemberAccessExpressionSyntax maes) return null;
        var name = maes.Name.Identifier.ValueText;

        var symbol = ctx.SemanticModel.GetSymbolInfo(maes).Symbol as IMethodSymbol;
        if (symbol is null) return null;
        if (symbol.Name is not ("BindTwoWay" or "BindOneWay" or "WhenChanged")) return null;

        var args = ies.ArgumentList.Arguments;
        string? fromPath = null, toPath = null, whenPath = null;
        LambdaExpressionSyntax? fromLambda = null, toLambda = null, whenLambda = null;

        if (symbol.Name == "WhenChanged")
        {
            if (args.Count < 1) return null;
            whenLambda = args[1 - 1].Expression as LambdaExpressionSyntax ?? TryExtractLambdaFromNameof(args[0].Expression);
            whenPath = whenLambda?.ToString();
        }
        else
        {
            if (args.Count < 4) return null;
            fromLambda = args[2].Expression as LambdaExpressionSyntax ?? TryExtractLambdaFromNameof(args[2].Expression);
            toLambda = args[3].Expression as LambdaExpressionSyntax ?? TryExtractLambdaFromNameof(args[3].Expression);
            fromPath = fromLambda?.ToString();
            toPath = toLambda?.ToString();
        }

        var model = new InvocationModel(symbol.Name, fromLambda, toLambda, whenLambda, fromPath, toPath, whenPath, ies.GetLocation());
        return model;
    }

    private static LambdaExpressionSyntax? TryExtractLambdaFromNameof(ExpressionSyntax expr) => expr as LambdaExpressionSyntax;
}

internal sealed record InvocationModel(
    string Kind,
    LambdaExpressionSyntax? FromLambda,
    LambdaExpressionSyntax? ToLambda,
    LambdaExpressionSyntax? WhenLambda,
    string? FromPath,
    string? ToPath,
    string? WhenPath,
    Location Location);

internal sealed class CodeEmitter
{
    public string Emit(ImmutableArray<InvocationModel> invocations)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using R3;");
        sb.AppendLine("namespace R3Ext;");
        sb.AppendLine("public static partial class BindingExtensions");
        sb.AppendLine("{");

        // Group invocations by kind and generate dispatch switches
        EmitBindOneWay(invocations.Where(i => i.Kind == "BindOneWay").ToImmutableArray(), sb);
        EmitBindTwoWay(invocations.Where(i => i.Kind == "BindTwoWay").ToImmutableArray(), sb);
        EmitWhenChanged(invocations.Where(i => i.Kind == "WhenChanged").ToImmutableArray(), sb);

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string Hash(string s)
    {
        // FNV-1a 32-bit for compact method names
        unchecked
        {
            uint hash = 2166136261;
            foreach (var ch in s)
            {
                hash ^= ch;
                hash *= 16777619;
            }
            return hash.ToString("x8");
        }
    }

    private void EmitBindOneWay(ImmutableArray<InvocationModel> models, StringBuilder sb)
    {
        if (models.IsDefaultOrEmpty)
        {
            // Emit the partial signature to satisfy references even if unused in this compilation
            sb.AppendLine("    public static partial IDisposable BindOneWay<TFrom,TFromProperty,TTarget,TTargetProperty>(this TFrom fromObject, TTarget targetObject, Expression<Func<TFrom,TFromProperty>> fromProperty, Expression<Func<TTarget,TTargetProperty>> toProperty, Func<TFromProperty,TTargetProperty>? conversionFunc = null, [CallerArgumentExpression(\"fromProperty\")] string? fromPropertyPath = null, [CallerArgumentExpression(\"toProperty\")] string? toPropertyPath = null);");
            return;
        }

        sb.AppendLine("    public static partial IDisposable BindOneWay<TFrom,TFromProperty,TTarget,TTargetProperty>(this TFrom fromObject, TTarget targetObject, Expression<Func<TFrom,TFromProperty>> fromProperty, Expression<Func<TTarget,TTargetProperty>> toProperty, Func<TFromProperty,TTargetProperty>? conversionFunc = null, [CallerArgumentExpression(\"fromProperty\")] string? fromPropertyPath = null, [CallerArgumentExpression(\"toProperty\")] string? toPropertyPath = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (fromPropertyPath)");
        sb.AppendLine("        {");
        foreach (var m in models)
        {
            if (m.FromPath is null || m.ToPath is null) continue;
            var key1 = m.FromPath;
            var key2 = m.ToPath;
            var id = Hash(key1 + "|" + key2);
            sb.AppendLine($"            case \"{Escape(key1)}\":");
            sb.AppendLine("                switch (toPropertyPath)");
            sb.AppendLine("                {");
            sb.AppendLine($"                    case \"{Escape(key2)}\": return __BindOneWay_{id}(fromObject, targetObject, conversionFunc);");
            sb.AppendLine("                }");
            sb.AppendLine("                break;");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        throw new NotSupportedException(\"No generated binding for provided property paths.\");");
        sb.AppendLine("    }");

        // Emit method bodies for each binding
        foreach (var m in models)
        {
            if (m.FromPath is null || m.ToPath is null || m.FromLambda is null || m.ToLambda is null) continue;
            var id = Hash(m.FromPath + "|" + m.ToPath);
            EmitOneWayBody(id, m, sb);
        }
    }

    private void EmitBindTwoWay(ImmutableArray<InvocationModel> models, StringBuilder sb)
    {
        if (models.IsDefaultOrEmpty)
        {
            sb.AppendLine("    public static partial IDisposable BindTwoWay<TFrom,TFromProperty,TTarget,TTargetProperty>(this TFrom fromObject, TTarget targetObject, Expression<Func<TFrom,TFromProperty>> fromProperty, Expression<Func<TTarget,TTargetProperty>> toProperty, Func<TFromProperty,TTargetProperty>? hostToTargetConv = null, Func<TTargetProperty,TFromProperty>? targetToHostConv = null, [CallerArgumentExpression(\"fromProperty\")] string? fromPropertyPath = null, [CallerArgumentExpression(\"toProperty\")] string? toPropertyPath = null);");
            return;
        }

        sb.AppendLine("    public static partial IDisposable BindTwoWay<TFrom,TFromProperty,TTarget,TTargetProperty>(this TFrom fromObject, TTarget targetObject, Expression<Func<TFrom,TFromProperty>> fromProperty, Expression<Func<TTarget,TTargetProperty>> toProperty, Func<TFromProperty,TTargetProperty>? hostToTargetConv = null, Func<TTargetProperty,TFromProperty>? targetToHostConv = null, [CallerArgumentExpression(\"fromProperty\")] string? fromPropertyPath = null, [CallerArgumentExpression(\"toProperty\")] string? toPropertyPath = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (fromPropertyPath)");
        sb.AppendLine("        {");
        foreach (var m in models)
        {
            if (m.FromPath is null || m.ToPath is null) continue;
            var key1 = m.FromPath;
            var key2 = m.ToPath;
            var id = Hash(key1 + "|" + key2);
            sb.AppendLine($"            case \"{Escape(key1)}\":");
            sb.AppendLine("                switch (toPropertyPath)");
            sb.AppendLine("                {");
            sb.AppendLine($"                    case \"{Escape(key2)}\": return __BindTwoWay_{id}(fromObject, targetObject, hostToTargetConv, targetToHostConv);");
            sb.AppendLine("                }");
            sb.AppendLine("                break;");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        throw new NotSupportedException(\"No generated two-way binding for provided property paths.\");");
        sb.AppendLine("    }");

        foreach (var m in models)
        {
            if (m.FromPath is null || m.ToPath is null || m.FromLambda is null || m.ToLambda is null) continue;
            var id = Hash(m.FromPath + "|" + m.ToPath);
            EmitTwoWayBody(id, m, sb);
        }
    }

    private void EmitWhenChanged(ImmutableArray<InvocationModel> models, StringBuilder sb)
    {
        if (models.IsDefaultOrEmpty)
        {
            sb.AppendLine("    public static partial Observable<TReturn> WhenChanged<TObj,TReturn>(this TObj objectToMonitor, Expression<Func<TObj,TReturn>> propertyExpression, [CallerArgumentExpression(\"propertyExpression\")] string? propertyExpressionPath = null);");
            return;
        }

        sb.AppendLine("    public static partial Observable<TReturn> WhenChanged<TObj,TReturn>(this TObj objectToMonitor, Expression<Func<TObj,TReturn>> propertyExpression, [CallerArgumentExpression(\"propertyExpression\")] string? propertyExpressionPath = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (propertyExpressionPath)");
        sb.AppendLine("        {");
        foreach (var m in models)
        {
            if (m.WhenPath is null) continue;
            var id = Hash(m.WhenPath);
            sb.AppendLine($"            case \"{Escape(m.WhenPath)}\": return __WhenChanged_{id}(objectToMonitor);");
        }
        sb.AppendLine("        }");
        sb.AppendLine("        throw new NotSupportedException(\"No generated WhenChanged for provided property expression.\");");
        sb.AppendLine("    }");

        foreach (var m in models)
        {
            if (m.WhenPath is null || m.WhenLambda is null) continue;
            var id = Hash(m.WhenPath);
            EmitWhenBody(id, m, sb);
        }
    }

    private static string Escape(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");

    private void EmitOneWayBody(string id, InvocationModel m, StringBuilder sb)
    {
        // For v1: minimal chain handling via INPC event listening; fallback to EveryValueChanged when parent not INPC.
        sb.AppendLine($"    private static IDisposable __BindOneWay_{id}<TFrom,TFromProperty,TTarget,TTargetProperty>(TFrom fromObject, TTarget targetObject, Func<TFromProperty,TTargetProperty>? convert)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (fromObject is null || targetObject is null) return Disposable.Empty;");
        sb.AppendLine("        convert ??= v => (TTargetProperty)(object?)v!;");
        sb.AppendLine("        System.ComponentModel.PropertyChangedEventHandler? h = null;");
        sb.AppendLine("        void Update()");
        sb.AppendLine("        {");
        sb.AppendLine("            try");
        sb.AppendLine("            {");
        sb.AppendLine(GenerateDirectSetFromTo(m.FromLambda!, m.ToLambda!, oneWay:true));
        sb.AppendLine("            }");
        sb.AppendLine("            catch { }");
        sb.AppendLine("        }");
        sb.AppendLine("        if (fromObject is System.ComponentModel.INotifyPropertyChanged fromNpc)");
        sb.AppendLine("        {");
        sb.AppendLine($"            h = (s,e) => {{ if (e.PropertyName == \"{ExtractTopMemberName(m.FromLambda!)}\") Update(); }};");
        sb.AppendLine("            fromNpc.PropertyChanged += h;");
        sb.AppendLine("        }");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine("            // Fallback: poll changes using R3 Observable.EveryValueChanged if available (no-op if not)");
        sb.AppendLine("            try { Observable.EveryValueChanged(fromObject, _ => " + ExtractMemberAccess(m.FromLambda!) + ").Subscribe(_ => Update()); } catch { } ");
        sb.AppendLine("        }");
        sb.AppendLine("        Update();");
        sb.AppendLine("        return Disposable.Create(() => { if (h != null && fromObject is System.ComponentModel.INotifyPropertyChanged npc) npc.PropertyChanged -= h; });");
        sb.AppendLine("    }");
    }

    private void EmitTwoWayBody(string id, InvocationModel m, StringBuilder sb)
    {
        sb.AppendLine($"    private static IDisposable __BindTwoWay_{id}<TFrom,TFromProperty,TTarget,TTargetProperty>(TFrom fromObject, TTarget targetObject, Func<TFromProperty,TTargetProperty>? hostToTarget, Func<TTargetProperty,TFromProperty>? targetToHost)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (fromObject is null || targetObject is null) return Disposable.Empty;");
        sb.AppendLine("        hostToTarget ??= v => (TTargetProperty)(object?)v!;");
        sb.AppendLine("        targetToHost ??= v => (TFromProperty)(object?)v!;");
        sb.AppendLine("        bool isUpdating = false;");
        sb.AppendLine("        var disposables = new System.Collections.Generic.List<IDisposable>(2);");
        sb.AppendLine("        void UpdateTarget(){ if (isUpdating) return; isUpdating = true; try { ");
        sb.AppendLine(GenerateDirectSetFromTo(m.FromLambda!, m.ToLambda!, oneWay:false));
        sb.AppendLine("        } finally { isUpdating = false; } }");
        sb.AppendLine("        void UpdateHost(){ if (isUpdating) return; isUpdating = true; try { ");
        sb.AppendLine(GenerateDirectSetFromTo(m.ToLambda!, m.FromLambda!, oneWay:false, reverse:true));
        sb.AppendLine("        } finally { isUpdating = false; } }");
        sb.AppendLine(GenerateWireForChains(m.FromLambda!, m.ToLambda!, oneWay:false));
        sb.AppendLine("        UpdateTarget();");
        sb.AppendLine("        return Disposable.Create(() => { foreach (var d in disposables) d.Dispose(); });");
        sb.AppendLine("    }");
    }

    private void EmitWhenBody(string id, InvocationModel m, StringBuilder sb)
    {
        sb.AppendLine($"    private static Observable<TReturn> __WhenChanged_{id}<TObj,TReturn>(TObj root)");
        sb.AppendLine("    {");
        sb.AppendLine(GenerateWhenObservable(m.WhenLambda!));
        sb.AppendLine("    }");
    }

    // Placeholder emitters â€” later passes will expand to full n-length chain support without reflection/expression compilation.
    private static string GenerateDirectSetFromTo(LambdaExpressionSyntax from, LambdaExpressionSyntax to, bool oneWay, bool reverse = false)
    {
        // Expect simple member chains only (validated by analysis phase in later pass)
        // For initial version: single-level property support, to be extended.
        var fromAccess = ExtractMemberAccess(from);
        var toAccess = ExtractMemberAccess(to);
        var valVar = reverse ? "vTo" : "vFrom";
        var conv = reverse ? "targetToHost" : "hostToTarget";
        var sb = new StringBuilder();
        sb.AppendLine($"                    var {valVar} = {fromAccess};");
        sb.AppendLine(oneWay
            ? $"                    {toAccess} = convert != null ? convert({valVar}) : (TTargetProperty)(object?){valVar}!;"
            : $"                    {toAccess} = {conv} != null ? {conv}({valVar}) : ({(reverse ? "TFromProperty" : "TTargetProperty")})(object?){valVar}!;");
        return sb.ToString();
    }

    private static string GenerateWireForChains(LambdaExpressionSyntax from, LambdaExpressionSyntax to, bool oneWay)
    {
        var fromMember = ExtractTopMemberName(from);
        var toMember = ExtractTopMemberName(to);
        var sb = new StringBuilder();
        sb.AppendLine("            if (fromObject is System.ComponentModel.INotifyPropertyChanged fromNpc)");
        sb.AppendLine("            {");
        sb.AppendLine($"                System.ComponentModel.PropertyChangedEventHandler h = (s,e) => {{ if (e.PropertyName == \\\"{fromMember}\\\") Update(); }};");
        sb.AppendLine("                fromNpc.PropertyChanged += h;");
        sb.AppendLine("                disposables.Add(Disposable.Create(() => fromNpc.PropertyChanged -= h));");
        sb.AppendLine("            }");
        if (!oneWay)
        {
            sb.AppendLine("            if (targetObject is System.ComponentModel.INotifyPropertyChanged toNpc)");
            sb.AppendLine("            {");
            sb.AppendLine($"                System.ComponentModel.PropertyChangedEventHandler h2 = (s,e) => {{ if (e.PropertyName == \\\"{toMember}\\\") UpdateHost(); }};");
            sb.AppendLine("                toNpc.PropertyChanged += h2;");
            sb.AppendLine("                disposables.Add(Disposable.Create(() => toNpc.PropertyChanged -= h2));");
            sb.AppendLine("            }");
        }
        return sb.ToString();
    }

    private static string GenerateWhenObservable(LambdaExpressionSyntax lambda)
    {
        var member = ExtractTopMemberName(lambda);
        var getter = ExtractMemberAccess(lambda, rootParam:"root");
        var sb = new StringBuilder();
        sb.AppendLine("        if (root is System.ComponentModel.INotifyPropertyChanged npc)");
        sb.AppendLine("        {");
        sb.AppendLine("            return Observable.Create<TReturn>(obs => { ");
        sb.AppendLine("                void emit(){ try { obs.OnNext(" + getter + "); } catch { obs.OnNext(default!); } }");
        sb.AppendLine($"                System.ComponentModel.PropertyChangedEventHandler h = (s,e) => {{ if (e.PropertyName == \"{member}\") emit(); }};");
        sb.AppendLine("                npc.PropertyChanged += h; emit();");
        sb.AppendLine("                return Disposable.Create(() => npc.PropertyChanged -= h);");
        sb.AppendLine("            });");
        sb.AppendLine("        }");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine("            // Fallback polling for non-INPC roots using EveryValueChanged if present");
        sb.AppendLine("            return Observable.EveryValueChanged(root, _ => " + getter + ")")
        sb.AppendLine("                .Select(v => (TReturn)v)");
        sb.AppendLine("                .DistinctUntilChanged();");
        sb.AppendLine("        }");
        return sb.ToString();
    }

    private static string ExtractMemberAccess(LambdaExpressionSyntax lambda, string rootParam = null!)
    {
        // very limited: param => param.Member
        if (lambda is SimpleLambdaExpressionSyntax simple)
        {
            var paramName = rootParam ?? simple.Parameter.Identifier.ValueText;
            if (simple.Body is MemberAccessExpressionSyntax maes)
            {
                return paramName + "." + maes.Name.Identifier.ValueText;
            }
        }
        return "default!";
    }

    private static string ExtractTopMemberName(LambdaExpressionSyntax lambda)
    {
        if (lambda is SimpleLambdaExpressionSyntax simple && simple.Body is MemberAccessExpressionSyntax maes)
        {
            return maes.Name.Identifier.ValueText;
        }
        return string.Empty;
    }
}
